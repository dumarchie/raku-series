#!/usr/bin/env raku
use v6.d;

use lib 'lib';
use Series;

constant Format = "%-60s%0.3fs\n";
sub benchmark(&work, $desc) {
    my \result = work;
    printf Format, $desc, now - ENTER now;
    result;
}

my %Build = (
  infix => {
      my Series $series;
      benchmark {
          $series := $_ :: $series for (^$_).reverse;
          $series;
      }, "Use infix :: to create a Series of $_ nodes";
  },
  insert => {
      my Series $series;
      benchmark {
          $series := $series.insert($_) for (^$_).reverse;
          $series;
      }, "Use .insert(value) to create a Series of $_ nodes";
  },
  new => {
      benchmark {
          Series.new(slip ^$_);
      }, "Use .new(slip values) to create a Series of $_ nodes";
  },
  prepend => {
      benchmark {
          Series.prepend(^$_);
      }, "Use .prepend(values) to create a Series of $_ nodes";
  },
);

my %Traversal = (
  elems => -> Mu $_ is raw, *%_ {
      benchmark {
          .elems;
      }, '.elems';
  },
  list => -> Mu $_ is raw, *%_ {
      benchmark {
          .list.elems;
      }, '.list.elems';
  },
  skip => -> Mu $_ is raw, :$nodes {
      benchmark {
          .skip($nodes);
      }, ".skip($nodes)";
  },
);

enum Build     <infix insert new prepend>;
enum Traversal <elems list skip>;
constant cores = $*KERNEL.cpu-cores;

sub MAIN(
  Int()     :$nodes   = 3E6,   #= number of nodes in the series
  Build     :$method  = infix, #= method to create the series
  Traversal :$assess  = elems, #= traversal method to assess
  Int       :$workers = cores, #= number of parallel workers
) {
    my &build    = %Build{$method};
    my &traverse = %Traversal{$assess};
    if $workers > 0 {
        benchmark {
            my \series = build($nodes);
            await (^$workers).map: {
                start traverse(series, :$nodes)
            };
        }, 'Total time';
    }
    else {
        benchmark {
            my \series = build($nodes);
            traverse(series, :$nodes);
        }, 'Total time';
    }
}
